generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "windows"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  SUPERADMIN
  ADMIN
  USER
}

enum PuzzleCategory {
  MUSIC
  MOVIES_TV
  GAMES
  SPORTS
  BOOKS
  UNCATEGORIZED
}

model User {
  id                 String              @id @default(uuid())
  clerkId            String              @unique
  role               UserRole            @default(USER)
  stripeCustomerId   String?             @unique
  stripeSubscription StripeSubscription?
  transactions       Transaction[]

  archived  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  attempts         PuzzleAttempt[]
  gameSessions     GameSession[]
  playerStatistics PlayerStatistics?
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  INCOMPLETE
  INCOMPLETE_EXPIRED
  PAST_DUE
  PAUSED
  TRIALING
  UNPAID
}

enum BillingInterval {
  MONTHLY
  YEARLY
}

model StripeSubscription {
  id                       String             @id @default(uuid())
  stripeSubscriptionId     String?            @unique
  stripeSubscriptionItemId String? // Stripe subscription item ID for updating quantity
  status                   SubscriptionStatus @default(INCOMPLETE)
  billingInterval          BillingInterval    @default(MONTHLY)
  quantity                 Int                @default(0)
  userId                   String             @unique
  user                     User               @relation(fields: [userId], references: [id])
  createdAt                DateTime           @default(now())
  updatedAt                DateTime           @updatedAt
  transactions             Transaction[]
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
}

// TODO: we will probably have some one-off purchases here
enum TransactionType {
  SUBSCRIPTION
}

model Transaction {
  id                String              @id @default(uuid())
  checkoutSessionId String?             @unique
  userId            String
  user              User                @relation(fields: [userId], references: [id])
  amount            Int
  currency          String
  status            TransactionStatus   @default(PENDING)
  type              TransactionType     @default(SUBSCRIPTION)
  subscriptionId    String?
  subscription      StripeSubscription? @relation(fields: [subscriptionId], references: [id])
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
}

model Puzzle {
  id       String         @id @default(uuid())
  question String
  answer   String
  hints    String[]
  category PuzzleCategory @default(UNCATEGORIZED)
  // difficulty String (Let's make an enum for this when we implement)

  displayDate  DateTime?
  displayOrder Int?      @unique
  published    Boolean   @default(false)
  archived     Boolean   @default(false)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  attempts     PuzzleAttempt[]
  gameSessions GameSession[]
}

model PuzzleAttempt {
  id       String @id @default(uuid())
  puzzleId String
  puzzle   Puzzle @relation(fields: [puzzleId], references: [id], onDelete: Cascade)

  // For authenticated users
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // For anonymous users (hash of IP + User-Agent + puzzle ID + daily salt)
  userFingerprint String?

  submittedAnswer String
  isCorrect       Boolean
  ipAddress       String?
  userAgent       String?
  createdAt       DateTime @default(now())

  @@index([puzzleId, userFingerprint, createdAt])
  @@index([puzzleId, userId, createdAt])
  @@index([puzzleId, createdAt])
}

model GameSession {
  id          String    @id @default(uuid())
  userId      String
  puzzleId    String
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  guesses     Int       @default(0)
  solved      Boolean   @default(false)
  gaveUp      Boolean   @default(false)
  hintsUsed   Int       @default(0)
  solveTimeMs Int?

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  puzzle Puzzle @relation(fields: [puzzleId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([puzzleId])
  @@index([completedAt])
  @@index([userId, completedAt])
}

model PlayerStatistics {
  id                 String    @id @default(uuid())
  userId             String    @unique
  totalGames         Int       @default(0)
  gamesWon           Int       @default(0)
  currentStreak      Int       @default(0)
  longestStreak      Int       @default(0)
  averageGuesses     Float?
  averageSolveTimeMs Int?
  fastestSolveMs     Int?
  lastPlayedAt       DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([lastPlayedAt])
}
